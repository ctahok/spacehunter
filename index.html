<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceHunter - Universal Web Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0c;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #gameCanvas {
            border: 2px solid #00ccff;
            box-shadow: 0 0 30px hsla(0, 204, 255, 0.3),
                        inset 0 0 60px hsla(240, 50%, 5%, 0.8);
            cursor: crosshair;
            max-width: 100vw;
            max-height: 70vh;
            width: 900px;
            height: 700px;
            touch-action: none;
        }

        /* Mobile Controls - Hidden by default, shown via JavaScript */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: auto;
            width: auto;
            max-width: 90vw;
        }

        .mobile-controls.active {
            display: block !important;
        }

        .virtual-joystick {
            position: absolute;
            left: 20px;
            bottom: 20px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: hsla(0, 204, 255, 0.2);
            border: 3px solid #00ccff;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
        }

        .virtual-joystick.active {
            background: hsla(0, 204, 255, 0.4);
            transform: scale(0.95);
        }

        .virtual-joystick .knob {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #00ccff;
            position: absolute;
            transition: all 0.1s ease;
            box-shadow: 0 2px 8px hsla(0, 0, 0, 0.3);
        }

        .fire-button {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: hsla(255, 102, 102, 0.2);
            border: 3px solid #ff6666;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
            box-shadow: 0 4px 15px hsla(255, 102, 102, 0.3);
        }

        .fire-button.active {
            background: hsla(255, 102, 102, 0.4);
            transform: scale(0.95);
        }

        .fire-button .icon {
            font-size: 24px;
            color: #ff6666;
            font-weight: bold;
        }

        /* Touch feedback */
        .touch-feedback {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: hsla(0, 204, 255, 0.5);
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: touchPulse 0.3s ease-out;
            z-index: 999;
        }

        @keyframes touchPulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        /* HUD */
        .game-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }

        .score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: hsla(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #00ccff;
        }

        .score-display .label {
            color: #00ccff;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .score-display .value {
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ccff;
        }

        .level-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: hsla(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #ffff00;
        }

        .level-display .label {
            color: #ffff00;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .level-display .value {
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffff00;
        }

        .health-bar {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: hsla(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 25px;
            border: 2px solid #00ccff;
            min-width: 200px;
        }

        .health-bar .label {
            color: #00ccff;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-align: center;
        }

        .health-fill {
            height: 12px;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        /* Start Screen */
        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: hsla(240, 20%, 5%, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: auto;
        }

        .start-screen .title {
            font-size: 48px;
            color: #00ccff;
            text-shadow: 0 0 30px #00ccff;
            margin-bottom: 20px;
            text-align: center;
        }

        .start-screen .subtitle {
            font-size: 18px;
            color: #ffffff;
            margin-bottom: 40px;
            text-align: center;
        }

        .start-screen .instructions {
            background: hsla(0, 204, 255, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            max-width: 400px;
            border: 1px solid #00ccff;
        }

        .start-screen .instructions .title {
            font-size: 20px;
            color: #00ccff;
            margin-bottom: 15px;
            text-align: center;
        }

        .start-screen .instructions .text {
            color: #ffffff;
            line-height: 1.6;
            font-size: 16px;
        }

        .start-screen .start-button {
            background: #00ccff;
            padding: 15px 40px;
            border-radius: 30px;
            border: none;
            color: #000000;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px hsla(0, 204, 255, 0.3);
        }

        .start-screen .start-button:hover {
            background: #00ddff;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px hsla(0, 204, 255, 0.4);
        }

        /* Game Over Screen */
        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: hsla(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: auto;
        }

        .game-over-screen .title {
            font-size: 48px;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
            margin-bottom: 20px;
            text-align: center;
        }

        .game-over-screen .stats {
            background: hsla(0, 0, 0, 0.8);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid #ff0000;
        }

        .game-over-screen .stats .final-score,
        .game-over-screen .stats .final-level {
            color: white;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
        }

        .game-over-screen .stats .value {
            color: #ffff00;
            font-size: 24px;
            font-weight: bold;
        }

        .game-over-screen .restart-button {
            background: #ff0000;
            padding: 15px 40px;
            border-radius: 30px;
            border: none;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px hsla(255, 0, 0, 0.3);
        }

        .game-over-screen .restart-button:hover {
            background: #ff3333;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px hsla(255, 0, 0, 0.4);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .virtual-joystick,
            .fire-button {
                width: 70px;
                height: 70px;
            }

            .virtual-joystick .knob {
                width: 25px;
                height: 25px;
            }

            .fire-button .icon {
                font-size: 20px;
            }

            .score-display,
            .level-display {
                padding: 8px 15px;
            }

            .score-display .value,
            .level-display .value {
                font-size: 20px;
            }

            .health-bar {
                bottom: 100px;
                min-width: 180px;
            }
        }

        /* Desktop Optimizations */
        @media (min-width: 769px) {
            .mobile-controls {
                display: none !important;
            }

            #gameCanvas {
                cursor: crosshair;
                max-height: 70vh;
            }
        }

        /* Mobile Canvas Optimization */
        @media (max-width: 768px) {
            #gameCanvas {
                max-height: 90vh;
            }
        }

        /* High DPI Support */
        @media (-webkit-min-device-pixel-ratio: 2),
               (min-resolution: 192dpi) {
            #gameCanvas {
                image-rendering: -webkit-optimize-contrast;
                image-rendering: crisp-edges;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="900" height="700"></canvas>

        <!-- Mobile Controls (JavaScript will show/hide) -->
        <div class="mobile-controls" id="mobileControls">
            <div class="virtual-joystick" id="joystick">
                <div class="knob" id="joystickKnob"></div>
            </div>
            <div class="fire-button" id="fireButton">
                <div class="icon">ðŸ”«</div>
            </div>
        </div>

        <!-- Game HUD -->
        <div class="game-hud">
            <div class="score-display">
                <div class="label">SCORE</div>
                <div class="value" id="scoreValue">0</div>
            </div>
            <div class="level-display">
                <div class="label">LEVEL</div>
                <div class="value" id="levelValue">1</div>
            </div>
            <div class="health-bar">
                <div class="label">SHIELD</div>
                <div class="health-fill" id="healthFill"></div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <div class="title">ðŸš€ SpaceHunter</div>
        <div class="subtitle">Universal Web Edition</div>

        <div class="instructions">
            <div class="title">How to Play:</div>
            <div class="text" id="instructionsText">
                Desktop: WASD/Arrows to move, Space to shoot<br>
                Mobile: Virtual joystick + fire button
            </div>
        </div>

        <button class="start-button" id="startButton">ðŸŽ® Start Game</button>
    </div>

    <!-- Game Over Screen -->
    <div class="game-over-screen" id="gameOverScreen">
        <div class="title">GAME OVER</div>
        <div class="stats">
            <div class="final-score">Score: <span class="value" id="finalScore">0</span></div>
            <div class="final-level">Level: <span class="value" id="finalLevel">1</span></div>
        </div>
        <button class="restart-button" id="restartButton">ðŸ”„ Play Again</button>
    </div>

    <script>
        // ============================================
        // CONSTANTS
        // ============================================
        const CANVAS_WIDTH = 900;
        const CANVAS_HEIGHT = 700;
        const SHIP_SIZE = 20;
        const SHIP_THRUST = 300;
        const SHIP_FRICTION = 0.98;
        const SHIP_MAX_SPEED = 400;
        const SHIP_ROTATION_SPEED = 5;
        const BULLET_SPEED = 600;
        const BULLET_LIFETIME = 1.5;
        const FIRE_RATE = 0.15;
        const ASTEROID_SPEEDS = { LARGE: 60, MEDIUM: 90, SMALL: 130 };
        const ASTEROID_SIZES = { LARGE: 50, MEDIUM: 30, SMALL: 15 };
        const ASTEROID_SCORES = { LARGE: 20, MEDIUM: 50, SMALL: 100 };
        const ASTEROID_DAMAGE = { LARGE: 35, MEDIUM: 20, SMALL: 10 };
        const POWERUP_DURATION = 8;
        const POWERUP_FLICKER_START = 5;
        const WEAPON_UPGRADE_DURATION = 10;
        const LEVEL_THRESHOLD_BASE = 500;
        const LEVEL_MULTIPLIER = 1.5;

        // ============================================
        // UTILITY CLASSES
        // ============================================
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
            subtract(v) { return new Vector2(this.x - v.x, this.y - v.y); }
            multiply(s) { return new Vector2(this.x * s, this.y * s); }
            magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() {
                const mag = this.magnitude();
                return mag > 0 ? new Vector2(this.x / mag, this.y / mag) : new Vector2();
            }
            clone() { return new Vector2(this.x, this.y); }
        }

        const Utils = {
            random: (min, max) => Math.random() * (max - min) + min,
            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
            clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
            lerp: (a, b, t) => a + (b - a) * t,
            distance: (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2),
            angleToVector: (angle) => new Vector2(Math.cos(angle), Math.sin(angle)),
            wrapPosition: (pos, width, height, margin = 50) => {
                if (pos.x < -margin) pos.x = width + margin;
                if (pos.x > width + margin) pos.x = -margin;
                if (pos.y < -margin) pos.y = height + margin;
                if (pos.y > height + margin) pos.y = -margin;
            },

            detectDevice: () => {
                const ua = navigator.userAgent;
                const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
                const isSmallScreen = window.innerWidth < 1024;
                const hasTouch = 'ontouchstart' in window;

                return {
                    isMobile: isMobileUA || isSmallScreen || hasTouch,
                    isIOS: /iPad|iPhone|iPod/.test(ua),
                    isAndroid: /Android/.test(ua),
                    screenWidth: window.innerWidth,
                    screenHeight: window.innerHeight
                };
            }
        };

        // ============================================
        // AUDIO MANAGER
        // ============================================
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.isInitialized = false;
                this.gainNode = null;
            }

            async initialize() {
                if (this.isInitialized) return;

                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.connect(this.audioContext.destination);
                    this.gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);

                    // Unlock audio context
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }

                    this.isInitialized = true;
                    console.log('Audio initialized');
                } catch (error) {
                    console.warn('Audio init failed:', error);
                }
            }

            createTone(frequency, duration, type = 'square', volume = 0.1) {
                if (!this.isInitialized) return;

                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.type = type;
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);

                    gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);

                    oscillator.connect(gainNode);
                    gainNode.connect(this.gainNode);

                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + duration);
                } catch (error) {
                    console.warn('Tone creation failed:', error);
                }
            }

            playShoot() { this.createTone(800, 0.05, 'square', 0.08); }
            playExplosion(size = 'SMALL') {
                const freq = size === 'LARGE' ? 80 : size === 'MEDIUM' ? 120 : 180;
                this.createTone(freq, size === 'LARGE' ? 0.4 : 0.25, 'sawtooth', 0.15);
            }
            playPowerup() {
                [400, 500, 600, 800].forEach((freq, i) => {
                    setTimeout(() => this.createTone(freq, 0.1, 'sine', 0.1), i * 50);
                });
            }
            playHit() { this.createTone(100, 0.15, 'sawtooth', 0.2); }
            playLevelUp() {
                [300, 400, 500, 600, 800].forEach((freq, i) => {
                    setTimeout(() => this.createTone(freq, 0.15, 'sine', 0.12), i * 80);
                });
            }
        }

        // ============================================
        // ENTITIES
        // ============================================
        class Ship {
            constructor(x, y) {
                this.position = new Vector2(x, y);
                this.velocity = new Vector2();
                this.rotation = -Math.PI / 2;
                this.health = 100;
                this.maxHealth = 100;
                this.thrusting = false;
                this.fireCooldown = 0;
                this.weaponUpgrade = 0;
                this.invulnerable = 0;
            }

            update(dt, input) {
                // Rotation
                if (input.left) this.rotation -= SHIP_ROTATION_SPEED * dt;
                if (input.right) this.rotation += SHIP_ROTATION_SPEED * dt;

                // Thrust
                this.thrusting = input.thrust;
                if (this.thrusting) {
                    const thrustVector = Utils.angleToVector(this.rotation);
                    this.velocity = this.velocity.add(thrustVector.multiply(SHIP_THRUST * dt));
                }

                // Friction
                this.velocity = this.velocity.multiply(SHIP_FRICTION);

                // Speed limit
                const speed = this.velocity.magnitude();
                if (speed > SHIP_MAX_SPEED) {
                    this.velocity = this.velocity.normalize().multiply(SHIP_MAX_SPEED);
                }

                // Position
                this.position = this.position.add(this.velocity.clone().multiply(dt));
                Utils.wrapPosition(this.position, CANVAS_WIDTH, CANVAS_HEIGHT, SHIP_SIZE);

                // Firing
                this.fireCooldown -= dt;
                if (input.shoot && this.fireCooldown <= 0) {
                    this.fireCooldown = FIRE_RATE;
                    return this.createBullet();
                }

                // Weapon upgrade timer
                if (this.weaponUpgrade > 0) this.weaponUpgrade -= dt;
                if (this.invulnerable > 0) this.invulnerable -= dt;

                return null;
            }

            createBullet() {
                const noseX = this.position.x + Math.cos(this.rotation) * SHIP_SIZE;
                const noseY = this.position.y + Math.sin(this.rotation) * SHIP_SIZE;

                if (this.weaponUpgrade > 0) {
                    return [
                        { x: noseX, y: noseY, angle: this.rotation - 0.15 },
                        { x: noseX, y: noseY, angle: this.rotation },
                        { x: noseX, y: noseY, angle: this.rotation + 0.15 }
                    ];
                } else {
                    return [{ x: noseX, y: noseY, angle: this.rotation }];
                }
            }

            takeDamage(amount) {
                if (this.invulnerable > 0) return false;
                this.health -= amount;
                this.invulnerable = 0.5;
                return this.health <= 0;
            }

            reset() {
                this.position = new Vector2(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                this.velocity = new Vector2();
                this.rotation = -Math.PI / 2;
                this.health = 100;
                this.fireCooldown = 0;
                this.weaponUpgrade = 0;
                this.invulnerable = 0;
            }

            render(ctx, scaleX = 1, scaleY = 1) {
                const x = this.position.x * scaleX;
                const y = this.position.y * scaleY;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.rotation);

                // Ship body
                ctx.beginPath();
                ctx.moveTo(SHIP_SIZE * scaleX, 0);
                ctx.lineTo(-SHIP_SIZE * 0.7 * scaleX, -SHIP_SIZE * 0.6 * scaleY);
                ctx.lineTo(-SHIP_SIZE * 0.4 * scaleX, 0);
                ctx.lineTo(-SHIP_SIZE * 0.7 * scaleX, SHIP_SIZE * 0.6 * scaleY);
                ctx.closePath();

                // Glow effect
                ctx.shadowColor = '#00ccff';
                ctx.shadowBlur = 15;

                const gradient = ctx.createLinearGradient(
                    -SHIP_SIZE * scaleX, 0,
                    SHIP_SIZE * scaleX, 0
                );
                gradient.addColorStop(0, '#ff3366');
                gradient.addColorStop(0.5, '#00ccff');
                gradient.addColorStop(1, '#ff3366');

                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        class Bullet {
            constructor() {
                this.position = new Vector2();
                this.velocity = new Vector2();
                this.life = 0;
                this.active = false;
                this.radius = 3;
            }

            init(x, y, angle) {
                this.position = new Vector2(x, y);
                this.velocity = Utils.angleToVector(angle).multiply(BULLET_SPEED);
                this.life = BULLET_LIFETIME;
                this.active = true;
            }

            update(dt) {
                if (!this.active) return false;

                this.position = this.position.add(this.velocity.clone().multiply(dt));
                this.life -= dt;

                if (this.life <= 0 ||
                    this.position.x < 0 || this.position.x > CANVAS_WIDTH ||
                    this.position.y < 0 || this.position.y > CANVAS_HEIGHT) {
                    this.active = false;
                    return false;
                }

                return true;
            }

            render(ctx, scaleX = 1, scaleY = 1) {
                if (!this.active) return;

                const x = this.position.x * scaleX;
                const y = this.position.y * scaleY;

                // Glow effect
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, this.radius * scaleX * 3);
                gradient.addColorStop(0, '#ffff80');
                gradient.addColorStop(0.5, '#ffff80');
                gradient.addColorStop(1, 'transparent');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, this.radius * scaleX * 3, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = '#ffff80';
                ctx.beginPath();
                ctx.arc(x, y, this.radius * scaleX, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Asteroid {
            constructor() {
                this.position = new Vector2();
                this.velocity = new Vector2();
                this.rotation = 0;
                this.rotationSpeed = 0;
                this.size = 'LARGE';
                this.radius = 0;
                this.vertices = [];
                this.active = false;
            }

            init(x, y, size) {
                this.position = new Vector2(x, y);
                this.size = size;
                this.radius = ASTEROID_SIZES[size];

                const speed = ASTEROID_SPEEDS[size] * Utils.random(0.8, 1.2);
                const angle = Utils.random(0, Math.PI * 2);
                this.velocity = Utils.angleToVector(angle).multiply(speed);

                this.rotation = 0;
                this.rotationSpeed = Utils.random(-1.5, 1.5);
                this.generateShape();
                this.active = true;
            }

            generateShape() {
                this.vertices = [];
                const numVertices = Utils.randomInt(8, 12);
                for (let i = 0; i < numVertices; i++) {
                    const angle = (i / numVertices) * Math.PI * 2;
                    const variance = Utils.random(0.7, 1.0);
                    this.vertices.push(new Vector2(
                        Math.cos(angle) * this.radius * variance,
                        Math.sin(angle) * this.radius * variance
                    ));
                }
            }

            update(dt) {
                if (!this.active) return;

                this.position = this.position.add(this.velocity.clone().multiply(dt));
                this.rotation += this.rotationSpeed * dt;

                Utils.wrapPosition(this.position, CANVAS_WIDTH, CANVAS_HEIGHT, this.radius);
            }

            render(ctx, scaleX = 1, scaleY = 1) {
                if (!this.active) return;

                const x = this.position.x * scaleX;
                const y = this.position.y * scaleY;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.rotation);

                // Ensure clean path for each asteroid
                ctx.beginPath();

                // Create asteroid shape
                ctx.moveTo(this.vertices[0].x * scaleX, this.vertices[0].y * scaleY);
                for (let i = 1; i < this.vertices.length; i++) {
                    ctx.lineTo(this.vertices[i].x * scaleX, this.vertices[i].y * scaleY);
                }
                ctx.closePath();

                // Gradient fill
                const gradient = ctx.createRadialGradient(
                    -this.radius * scaleX * 0.3, -this.radius * scaleY * 0.3, 0,
                    0, 0, this.radius * Math.max(scaleX, scaleY)
                );
                gradient.addColorStop(0, '#8B4513');
                gradient.addColorStop(0.5, '#654321');
                gradient.addColorStop(1, '#321000');

                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = '#8B7355';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            split() {
                if (this.size === 'LARGE') {
                    const angle1 = Utils.random(0, Math.PI * 2);
                    const angle2 = Utils.random(0, Math.PI * 2);
                    const speed = ASTEROID_SPEEDS.MEDIUM * Utils.random(0.8, 1.2);
                    return [
                        { size: 'MEDIUM', x: this.position.x, y: this.position.y, vx: Math.cos(angle1) * speed, vy: Math.sin(angle1) * speed },
                        { size: 'MEDIUM', x: this.position.x, y: this.position.y, vx: Math.cos(angle2) * speed, vy: Math.sin(angle2) * speed }
                    ];
                } else if (this.size === 'MEDIUM') {
                    const angle1 = Utils.random(0, Math.PI * 2);
                    const angle2 = Utils.random(0, Math.PI * 2);
                    const speed = ASTEROID_SPEEDS.SMALL * Utils.random(0.8, 1.2);
                    return [
                        { size: 'SMALL', x: this.position.x, y: this.position.y, vx: Math.cos(angle1) * speed, vy: Math.sin(angle1) * speed },
                        { size: 'SMALL', x: this.position.x, y: this.position.y, vx: Math.cos(angle2) * speed, vy: Math.sin(angle2) * speed }
                    ];
                }
                return [];
            }
        }

        class PowerUp {
            constructor() {
                this.position = new Vector2();
                this.type = 'HEALTH';
                this.radius = 15;
                this.life = 0;
                this.rotation = 0;
                this.active = false;
            }

            init(x, y, type) {
                this.position = new Vector2(x, y);
                this.type = type;
                this.radius = 15;
                this.life = POWERUP_DURATION;
                this.rotation = 0;
                this.active = true;
            }

            update(dt) {
                if (!this.active) return false;

                this.life -= dt;
                this.rotation += 2 * dt;

                if (this.life <= 0) {
                    this.active = false;
                    return false;
                }

                return true;
            }

            render(ctx, scaleX = 1, scaleY = 1) {
                if (!this.active) return;

                // Flicker when running out
                if (this.life < POWERUP_DURATION - POWERUP_FLICKER_START) {
                    if (Math.sin(this.life * 20) > 0) return;
                }

                const x = this.position.x * scaleX;
                const y = this.position.y * scaleY;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.rotation);

                const color = this.type === 'HEALTH' ? '#00ff00' : '#aa00ff';

                // Glow
                const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * scaleX * 1.5);
                glowGradient.addColorStop(0, color);
                glowGradient.addColorStop(1, 'transparent');

                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * scaleX * 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Shape
                ctx.fillStyle = color;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;

                if (this.type === 'HEALTH') {
                    // Cross shape
                    ctx.fillRect(-4 * scaleX, -12 * scaleY, 8 * scaleX, 24 * scaleY);
                    ctx.fillRect(-12 * scaleX, -4 * scaleY, 24 * scaleX, 8 * scaleY);
                } else {
                    // Arrow shape
                    ctx.beginPath();
                    ctx.moveTo(0, -12 * scaleY);
                    ctx.lineTo(10 * scaleX, 6 * scaleY);
                    ctx.lineTo(4 * scaleX, 6 * scaleY);
                    ctx.lineTo(4 * scaleX, 12 * scaleY);
                    ctx.lineTo(-4 * scaleX, 12 * scaleY);
                    ctx.lineTo(-4 * scaleX, 6 * scaleY);
                    ctx.lineTo(-10 * scaleX, 6 * scaleY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // ============================================
        // GAME ENGINE
        // ============================================
        class GameEngine {
            constructor() {
                this.ship = new Ship(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                this.bullets = [];
                this.asteroids = [];
                this.powerups = [];
                this.particles = [];

                this.state = {
                    score: 0,
                    level: 1,
                    gameOver: false,
                    paused: false,
                    started: false
                };

                this.asteroidSpawnTimer = 0;
                this.powerupSpawnTimer = 0;
                this.audioManager = new AudioManager();
                // Audio will be initialized when game starts (after user interaction)
            }

            start() {
                this.state.started = true;
                this.state.paused = false;
                this.reset();
                // Initialize audio after user interaction
                if (this.audioManager) {
                    this.audioManager.initialize();
                }
            }

            pause() {
                this.state.paused = !this.state.paused;
            }

            reset() {
                this.ship.reset();
                this.bullets = [];
                this.asteroids = [];
                this.powerups = [];
                this.particles = [];

                this.state.score = 0;
                this.state.level = 1;
                this.state.gameOver = false;
                this.asteroidSpawnTimer = 0;
                this.powerupSpawnTimer = 0;
            }

            update(dt, input) {
                if (this.state.gameOver || this.state.paused || !this.state.started) return;

                // Update ship
                const newBullets = this.ship.update(dt, input);
                if (newBullets) {
                    newBullets.forEach(bulletData => {
                        const bullet = new Bullet();
                        bullet.init(bulletData.x, bulletData.y, bulletData.angle);
                        this.bullets.push(bullet);
                    });
                    this.audioManager.playShoot();
                }

                // Update bullets
                this.bullets = this.bullets.filter(bullet => bullet.update(dt));

                // Update asteroids
                const difficultyMult = 1 + (this.state.level - 1) * 0.1;
                this.asteroids.forEach(asteroid => {
                    asteroid.velocity = asteroid.velocity.multiply(1 + (difficultyMult - 1) * dt * 0.1);
                    asteroid.update(dt);
                });

                // Update powerups
                this.powerups = this.powerups.filter(powerup => powerup.update(dt));

                // Update particles
                this.particles = this.particles.filter(particle => particle.update(dt));

                // Collision detection
                this.checkCollisions();

                // Spawning
                this.updateSpawning(dt);

                // Level progression
                this.checkLevelUp();
            }

            checkCollisions() {
                // Bullet-Asteroid collisions
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    if (!bullet.active) continue;

                    for (let j = this.asteroids.length - 1; j >= 0; j--) {
                        const asteroid = this.asteroids[j];
                        if (!asteroid.active) continue;

                        const distance = Utils.distance(bullet.position.x, bullet.position.y, asteroid.position.x, asteroid.position.y);
                        if (distance < asteroid.radius + bullet.radius) {
                            bullet.active = false;
                            this.destroyAsteroid(asteroid);
                            break;
                        }
                    }
                }

                // Ship-Asteroid collisions
                for (const asteroid of this.asteroids) {
                    if (!asteroid.active) continue;

                    const distance = Utils.distance(this.ship.position.x, this.ship.position.y, asteroid.position.x, asteroid.position.y);
                    if (distance < asteroid.radius + SHIP_SIZE * 0.6) {
                        if (this.ship.takeDamage(ASTEROID_DAMAGE[asteroid.size])) {
                            this.state.gameOver = true;
                            this.audioManager.playHit();
                        } else {
                            this.audioManager.playHit();
                        }
                        this.destroyAsteroid(asteroid);
                        break;
                    }
                }

                // Ship-Powerup collisions
                for (const powerup of this.powerups) {
                    if (!powerup.active) continue;

                    const distance = Utils.distance(this.ship.position.x, this.ship.position.y, powerup.position.x, powerup.position.y);
                    if (distance < powerup.radius + SHIP_SIZE * 0.6) {
                        this.collectPowerup(powerup);
                    }
                }
            }

            destroyAsteroid(asteroid) {
                asteroid.active = false;
                this.state.score += ASTEROID_SCORES[asteroid.size];

                // Create explosion particles
                this.createExplosion(asteroid.position.x, asteroid.position.y, asteroid.size);

                // Play explosion sound
                this.audioManager.playExplosion(asteroid.size);

                // Voice lines for large asteroids
                if (asteroid.size === 'LARGE') {
                    // Use Web Speech API if available
                    if (window.speechSynthesis) {
                        const lines = ["Nice shot!", "Boom!", "Got 'em!", "Oh yes!"];
                        const utterance = new SpeechSynthesisUtterance(lines[Math.floor(Math.random() * lines.length)]);
                        utterance.rate = 1.1;
                        utterance.pitch = 1.2;
                        utterance.volume = 0.8;
                        window.speechSynthesis.speak(utterance);
                    }
                }

                // Split into smaller asteroids
                const children = asteroid.split();
                children.forEach(child => {
                    const newAsteroid = new Asteroid();
                    newAsteroid.init(child.x, child.y, child.size);
                    newAsteroid.velocity = new Vector2(child.vx, child.vy);
                    this.asteroids.push(newAsteroid);
                });

                // Remove destroyed asteroid
                this.asteroids = this.asteroids.filter(a => a.active);
            }

            collectPowerup(powerup) {
                powerup.active = false;
                this.audioManager.playPowerup();

                if (powerup.type === 'HEALTH') {
                    this.ship.health = Math.min(100, this.ship.health + 25);
                } else if (powerup.type === 'WEAPON') {
                    this.ship.weaponUpgrade = WEAPON_UPGRADE_DURATION;
                }

                // Create collection particles
                this.createExplosion(powerup.position.x, powerup.position.y, 'COLLECT');

                // Remove collected powerup
                this.powerups = this.powerups.filter(p => p.active);
            }

            createExplosion(x, y, type) {
                const particleCount = type === 'LARGE' ? 20 : type === 'MEDIUM' ? 15 : type === 'COLLECT' ? 10 : 8;

                for (let i = 0; i < particleCount; i++) {
                    const particle = {
                        position: new Vector2(x, y),
                        velocity: Utils.angleToVector(Utils.random(0, Math.PI * 2)).multiply(Utils.random(50, type === 'LARGE' ? 200 : 150)),
                        color: type === 'COLLECT' ? '#00ff00' : '#ff6600',
                        life: Utils.random(0.2, type === 'LARGE' ? 0.6 : 0.4),
                        maxLife: 0,
                        size: Utils.random(2, type === 'LARGE' ? 6 : 4),
                        active: true,

                        update(dt) {
                            if (!this.active) return false;
                            this.position = this.position.add(this.velocity.clone().multiply(dt));
                            this.life -= dt;
                            if (this.life <= 0) {
                                this.active = false;
                                return false;
                            }
                            return true;
                        },

                        render(ctx, scaleX = 1, scaleY = 1) {
                            if (!this.active) return;
                            const x = this.position.x * scaleX;
                            const y = this.position.y * scaleY;
                            const alpha = this.life / this.maxLife;
                            const size = this.size * scaleX * alpha;

                            ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('#', 'rgba(').replace(/([0-9a-f]{2})/g, (m, p) => parseInt(p, 16) + ',');
                            ctx.beginPath();
                            ctx.arc(x, y, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    };
                    particle.maxLife = particle.life;
                    this.particles.push(particle);
                }
            }

            updateSpawning(dt) {
                // Asteroid spawning
                this.asteroidSpawnTimer -= dt;
                const spawnRate = Math.max(1.5, 4 - this.state.level * 0.2);
                if (this.asteroidSpawnTimer <= 0) {
                    this.spawnAsteroid();
                    this.asteroidSpawnTimer = spawnRate;
                }

                // Power-up spawning
                this.powerupSpawnTimer -= dt;
                if (this.powerupSpawnTimer <= 0) {
                    this.spawnPowerup();
                    this.powerupSpawnTimer = Utils.random(10, 20);
                }
            }

            spawnAsteroid() {
                const asteroid = new Asteroid();
                const edge = Utils.randomInt(0, 3);
                let x, y;

                switch (edge) {
                    case 0: x = Utils.random(0, CANVAS_WIDTH); y = -50; break;
                    case 1: x = CANVAS_WIDTH + 50; y = Utils.random(0, CANVAS_HEIGHT); break;
                    case 2: x = Utils.random(0, CANVAS_WIDTH); y = CANVAS_HEIGHT + 50; break;
                    case 3: x = -50; y = Utils.random(0, CANVAS_HEIGHT); break;
                }

                asteroid.init(x, y, 'LARGE');
                this.asteroids.push(asteroid);
            }

            spawnPowerup() {
                const powerup = new PowerUp();
                const type = Math.random() < 0.6 ? 'HEALTH' : 'WEAPON';
                powerup.init(
                    Utils.random(100, CANVAS_WIDTH - 100),
                    Utils.random(100, CANVAS_HEIGHT - 100),
                    type
                );
                this.powerups.push(powerup);
            }

            checkLevelUp() {
                const threshold = LEVEL_THRESHOLD_BASE * Math.pow(LEVEL_MULTIPLIER, this.state.level - 1);
                if (this.state.score >= threshold * this.state.level) {
                    this.state.level++;
                    this.audioManager.playLevelUp();
                }
            }

            render(ctx, scaleX = 1, scaleY = 1) {
                // Clear canvas
                ctx.fillStyle = '#0a0a0c';
                ctx.fillRect(0, 0, CANVAS_WIDTH * scaleX, CANVAS_HEIGHT * scaleY);

                if (!this.state.started) return;

                // Render particles (background)
                this.particles.forEach(particle => particle.render(ctx, scaleX, scaleY));

                // Render powerups
                this.powerups.forEach(powerup => powerup.render(ctx, scaleX, scaleY));

                // Render asteroids
                this.asteroids.forEach(asteroid => asteroid.render(ctx, scaleX, scaleY));

                // Render bullets
                this.bullets.forEach(bullet => bullet.render(ctx, scaleX, scaleY));

                // Render ship
                this.ship.render(ctx, scaleX, scaleY);
            }
        }

        // ============================================
        // INPUT HANDLER
        // ============================================
        class InputHandler {
            constructor(canvas) {
                this.canvas = canvas;
                this.keys = {};
                this.mouseX = CANVAS_WIDTH / 2;
                this.mouseY = CANVAS_HEIGHT / 2;
                this.mouseDown = false;

                this.device = Utils.detectDevice();
                this.isMobile = this.device.isMobile;
                this.touchActive = false;
                this.touchStartPos = { x: 0, y: 0 };

                // Virtual joystick state
                this.joystickActive = false;
                this.joystickCenter = { x: 0, y: 0 };
                this.joystickKnobOffset = { x: 0, y: 0 };

                // Fire button state
                this.fireButtonActive = false;

                // Show mobile controls if on mobile device
                if (this.isMobile) {
                    this.setupMobileControls();
                }

                // Keyboard controls (desktop only)
                window.addEventListener('keydown', e => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === ' ') e.preventDefault(); // Prevent space from scrolling
                });

                window.addEventListener('keyup', e => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                // Mouse controls (desktop only)
                if (!this.isMobile) {
                    canvas.addEventListener('mousemove', e => {
                        this.handleMouseMove(e);
                    });

                    canvas.addEventListener('mousedown', e => {
                        this.mouseDown = true;
                        this.showTouchFeedback(e.clientX, e.clientY);
                    });

                    canvas.addEventListener('mouseup', e => {
                        this.mouseDown = false;
                    });
                }

                // Touch controls (mobile priority)
                this.setupTouchControls();
            }

            setupMobileControls() {
                // Show virtual controls
                const controlsContainer = document.getElementById('mobileControls');
                if (controlsContainer) {
                    controlsContainer.classList.add('active');
                }

                // Virtual joystick
                const joystick = document.getElementById('joystick');
                if (joystick) {
                    joystick.addEventListener('touchstart', this.handleJoystickStart.bind(this));
                    joystick.addEventListener('touchmove', this.handleJoystickMove.bind(this));
                    joystick.addEventListener('touchend', this.handleJoystickEnd.bind(this));
                }

                // Fire button
                const fireButton = document.getElementById('fireButton');
                if (fireButton) {
                    fireButton.addEventListener('touchstart', this.handleFireStart.bind(this));
                    fireButton.addEventListener('touchend', this.handleFireEnd.bind(this));
                }
            }

            setupTouchControls() {
                // Canvas touch events (highest priority for mobile)
                this.canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    this.handleTouchStart(e);
                }, { passive: false });

                this.canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    this.handleTouchMove(e);
                }, { passive: false });

                this.canvas.addEventListener('touchend', e => {
                    e.preventDefault();
                    this.handleTouchEnd(e);
                }, { passive: false });
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = CANVAS_WIDTH / rect.width;
                const scaleY = CANVAS_HEIGHT / rect.height;

                this.mouseX = (e.clientX - rect.left) * scaleX;
                this.mouseY = (e.clientY - rect.top) * scaleY;
            }

            handleTouchStart(e) {
                if (e.touches.length > 0) {
                    this.touchActive = true;
                    this.handleTouchMove(e);
                    this.showTouchFeedback(e.touches[0].clientX, e.touches[0].clientY);
                }
            }

            handleTouchMove(e) {
                if (e.touches.length > 0) {
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = CANVAS_WIDTH / rect.width;
                    const scaleY = CANVAS_HEIGHT / rect.height;

                    this.mouseX = (e.touches[0].clientX - rect.left) * scaleX;
                    this.mouseY = (e.touches[0].clientY - rect.top) * scaleY;
                }
            }

            handleTouchEnd(e) {
                this.touchActive = false;
                this.mouseDown = false;
            }

            handleJoystickStart(e) {
                e.preventDefault();
                this.joystickActive = true;

                const joystick = e.target.closest('.virtual-joystick');
                const rect = joystick.getBoundingClientRect();
                this.joystickCenter = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                joystick.classList.add('active');
            }

            handleJoystickMove(e) {
                if (!this.joystickActive || e.touches.length === 0) return;

                e.preventDefault();

                const touch = e.touches[0];
                const dx = touch.clientX - this.joystickCenter.x;
                const dy = touch.clientY - this.joystickCenter.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 40; // Max joystick movement

                // Clamp to circle
                const clampedDistance = Math.min(distance, maxDistance);
                const angle = Math.atan2(dy, dx);

                this.joystickKnobOffset = {
                    x: Math.cos(angle) * clampedDistance,
                    y: Math.sin(angle) * clampedDistance
                };

                // Update joystick visual
                const knob = e.target.closest('.virtual-joystick').querySelector('.knob');
                if (knob) {
                    knob.style.transform = `translate(${this.joystickKnobOffset.x}px, ${this.joystickKnobOffset.y}px)`;
                }
            }

            handleJoystickEnd(e) {
                e.preventDefault();
                this.joystickActive = false;
                this.joystickKnobOffset = { x: 0, y: 0 };

                const joystick = e.target.closest('.virtual-joystick');
                joystick.classList.remove('active');

                const knob = joystick.querySelector('.knob');
                if (knob) {
                    knob.style.transform = 'translate(0px, 0px)';
                }
            }

            handleFireStart(e) {
                e.preventDefault();
                this.fireButtonActive = true;

                const button = e.target.closest('.fire-button');
                button.classList.add('active');
            }

            handleFireEnd(e) {
                e.preventDefault();
                this.fireButtonActive = false;

                const button = e.target.closest('.fire-button');
                button.classList.remove('active');
            }

            showTouchFeedback(x, y) {
                const feedback = document.createElement('div');
                feedback.className = 'touch-feedback';
                feedback.style.left = x + 'px';
                feedback.style.top = y + 'px';
                document.body.appendChild(feedback);

                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.parentNode.removeChild(feedback);
                    }
                }, 300);
            }

            getInput() {
                if (this.isMobile) {
                    // Mobile: Virtual controls with refined mapping
                    const deadZone = 8; // Dead zone to prevent jitter
                    const xOffset = Math.abs(this.joystickKnobOffset.x);
                    const yOffset = Math.abs(this.joystickKnobOffset.y);

                    return {
                        left: this.joystickKnobOffset.x < -deadZone, // Joystick left (rotation only)
                        right: this.joystickKnobOffset.x > deadZone, // Joystick right (rotation only)
                        thrust: this.joystickKnobOffset.y < -deadZone, // Upward movement only triggers thrust
                        shoot: this.fireButtonActive || this.touchActive // Fire button or screen touch
                    };
                } else {
                    // Desktop: Keyboard + mouse
                    return {
                        left: this.keys['a'] || this.keys['arrowleft'],
                        right: this.keys['d'] || this.keys['arrowright'],
                        thrust: this.keys['w'] || this.keys['arrowup'] || this.keys['s'] || this.keys['arrowdown'],
                        shoot: this.keys[' '] || this.mouseDown
                    };
                }
            }

            update() {
                return this.getInput();
            }
        }

        // ============================================
        // MAIN GAME CONTROLLER
        // ============================================
        class GameController {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameEngine = new GameEngine();
                this.inputHandler = new InputHandler(this.canvas);

                this.scaleX = 1;
                this.scaleY = 1;
                this.lastTime = 0;
                this.animationFrameId = null;

                this.device = Utils.detectDevice();

                this.setupEventListeners();
                this.setupCanvasScaling();
                this.updateInstructions();

                // Show start screen
                this.showStartScreen();

                console.log('GameController initialized:', this.device);
            }

            setupEventListeners() {
                // Start button
                document.getElementById('startButton').addEventListener('click', () => {
                    this.startGame();
                });

                // Restart button
                document.getElementById('restartButton').addEventListener('click', () => {
                    this.restartGame();
                });

                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvasScaling();
                });
            }

            setupCanvasScaling() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // Set actual canvas size in memory (scaled for retina displays)
                this.canvas.width = CANVAS_WIDTH * dpr;
                this.canvas.height = CANVAS_HEIGHT * dpr;

                // Scale the drawing context so everything draws at the correct size
                this.ctx.scale(dpr, dpr);

                // Calculate display scale
                this.scaleX = rect.width / CANVAS_WIDTH;
                this.scaleY = rect.height / CANVAS_HEIGHT;

                console.log('Canvas scaling:', { scaleX: this.scaleX, scaleY: this.scaleY, dpr });
            }

            updateInstructions() {
                const instructionsText = document.getElementById('instructionsText');
                if (this.device.isMobile) {
                    instructionsText.textContent =
                        'â€¢ Touch and drag the joystick to move your ship\n' +
                        'â€¢ Tap the fire button to shoot\n' +
                        'â€¢ Touch anywhere on screen for additional aiming';
                } else {
                    instructionsText.textContent =
                        'â€¢ Use WASD or Arrow Keys to move your ship\n' +
                        'â€¢ Press Space or click to shoot\n' +
                        'â€¢ Mouse for precise aiming';
                }
            }

            showStartScreen() {
                document.getElementById('startScreen').style.display = 'flex';
                document.getElementById('gameOverScreen').style.display = 'none';
            }

            startGame() {
                document.getElementById('startScreen').style.display = 'none';
                this.gameEngine.start();
                this.lastTime = performance.now();
                this.gameLoop();

                // Unlock audio context
                if (this.gameEngine.audioManager) {
                    this.gameEngine.audioManager.initialize();
                }
            }

            restartGame() {
                // Reset game engine state
                this.gameEngine.reset();

                // Explicitly reset HUD displays to prevent persistence
                document.getElementById('scoreValue').textContent = '0';
                document.getElementById('levelValue').textContent = '1';
                document.getElementById('healthFill').style.width = '100%';
                document.getElementById('healthFill').style.backgroundColor = '#00ff00';

                // Ensure game over screen is hidden
                document.getElementById('gameOverScreen').style.display = 'none';

                this.startGame();
            }

            gameLoop = () => {
                const currentTime = performance.now();
                const dt = Math.min((currentTime - this.lastTime) / 1000, 0.016); // Cap at ~60fps
                this.lastTime = currentTime;

                // Get input
                const input = this.inputHandler.update();

                // Update game
                this.gameEngine.update(dt, input);

                // Check for game over
                if (this.gameEngine.state.gameOver) {
                    this.showGameOver();
                    return;
                }

                // Render game
                this.gameEngine.render(this.ctx, this.scaleX, this.scaleY);

                // Update HUD
                this.updateHUD();

                // Continue loop
                this.animationFrameId = requestAnimationFrame(this.gameLoop);
            };

            updateHUD() {
                // Score
                document.getElementById('scoreValue').textContent = this.gameEngine.state.score.toLocaleString();

                // Level
                document.getElementById('levelValue').textContent = this.gameEngine.state.level;

                // Health
                const healthFill = document.getElementById('healthFill');
                const healthPercent = this.gameEngine.ship.health / 100;
                healthFill.style.width = `${healthPercent * 100}%`;

                // Health color
                if (healthPercent > 0.6) {
                    healthFill.style.backgroundColor = '#00ff00';
                } else if (healthPercent > 0.3) {
                    healthFill.style.backgroundColor = '#ffff00';
                } else {
                    healthFill.style.backgroundColor = '#ff0000';
                }
            }

            showGameOver() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }

                // Update final stats
                document.getElementById('finalScore').textContent = this.gameEngine.state.score.toLocaleString();
                document.getElementById('finalLevel').textContent = this.gameEngine.state.level;

                // Show game over screen
                document.getElementById('gameOverScreen').style.display = 'flex';
            }
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new GameController();
        });
    </script>
</body>
</html>
